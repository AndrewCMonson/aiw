/**
 * @copyright Copyright © 2025 Andrew Monson. All rights reserved.
 * @author    Andrew Monson <andrew.monson@elevate-digital.com>
 */

import { Command } from "commander";
import fs from "node:fs/promises";
import path from "node:path";
import { stdin as input, stdout as output } from "node:process";
import readline from "node:readline/promises";

import { mkdirp, safeWriteFile } from "../lib/fs.js";
import { installPrePushHook } from "../lib/hooks.js";
import { resolveWorkspacePaths } from "../lib/paths.js";
import { getAgentRuleFiles } from "../templates/agentRules.js";
import { DEFAULT_PROMPTS } from "../templates/defaultPrompts.js";
import { getProjectContextContent } from "../templates/projectContext.js";

function getSubdirectoryReadme(subdir: string): string {
    const descriptions: Record<string, { title: string; description: string }> = {
        repo_context: {
            title: "Repository Context",
            description:
                "Repository discovery notes (single file, updated in place) generated by `.ai/prompts/repo_discover.md` and `.ai/prompts/repo_refresh.md`",
        },
        pr_reviews: {
            title: "Pre-push Reviews",
            description: "Versioned pre-push review notes generated by `.ai/prompts/pre_push_review.md`",
        },
        feature_plans: {
            title: "Feature Plans",
            description: "Versioned feature planning documents generated by `.ai/prompts/feature_plan.md`",
        },
        debug_notes: {
            title: "Debug Notes",
            description: "Versioned debugging session notes generated by `.ai/prompts/debug_senior.md`",
        },
    };

    const info = descriptions[subdir] || { title: subdir, description: "Versioned context files" };

    if (subdir === "repo_context") {
        return `# ${info.title}

${info.description}

## File

This directory contains a single file:

- \`REPO_CONTEXT.md\` - Repository discovery notes (updated in place)

This file is not versioned. Each time you run \`.ai/prompts/repo_discover.md\` or \`.ai/prompts/repo_refresh.md\`, the file is updated with the latest repository context.
`;
    }

    return `# ${info.title}

${info.description}

## Filename Format

Files in this directory use the following naming format:

\`YYYY-MM-DD_HHMMSS_<id>_<descriptor>.md\`

- \`YYYY-MM-DD_HHMMSS\` - Timestamp when the file was created (24-hour format)
- \`<id>\` - Unique 6-8 character identifier
- \`<descriptor>\` - Descriptive name (includes branch name for features/bugs)

## Examples

- \`2024-01-15_143022_a3f9b2_feature-user-auth_oauth-integration.md\`
- \`2024-01-15_143022_b7c4d1_bugfix-login-error_null-pointer.md\`

## Finding Files

- List all files: \`ls .ai/context/${subdir}/\`
- Find by date: \`ls .ai/context/${subdir}/ | grep 2024-01-15\`
- Find by branch: \`ls .ai/context/${subdir}/ | grep feature-user-auth\`
`;
}

function getDebugNotesPlaceholder(): string {
    return `# Debug Notes Template

> This is a template showing the expected structure for debug notes.
> Actual files will be named: \`YYYY-MM-DD_HHMMSS_<id>_<descriptor>.md\`
> Generated by: \`.ai/prompts/debug_senior.md\`

## 1. Symptom summary
- What is failing, where, and impact

## 2. Repro notes
- Steps (or "cannot reproduce")
- Expected vs actual
- Environment (versions/OS)

## 3. Hypotheses (ranked)
1. Hypothesis — why — fast check
2. Hypothesis — why — fast check
3. ...

## 4. Evidence / experiments
- Observations collected
- Experiments run + outcomes
- Links to relevant files/lines (paths only)

## 5. Root cause
- Statement of root cause (or "unknown")
- Confidence: high / medium / low
- Evidence: ...

## 6. Fix plan
- Minimal fix (steps + files)
- Safety checks / rollout considerations (if applicable)

## 7. Regression tests
- What to add/change (test type + location)
- Commands to run
`;
}

function getFeaturePlansPlaceholder(): string {
    return `# Feature Plan Template

> This is a template showing the expected structure for feature plans.
> Actual files will be named: \`YYYY-MM-DD_HHMMSS_<id>_<descriptor>.md\`
> Generated by: \`.ai/prompts/feature_plan.md\`

## 1. Summary
- **Feature:** (one sentence)
- **Goals:** (bullets)
- **Non-goals:** (bullets)
- **Constraints:** (bullets)
- **Acceptance criteria:** (bullets)

## 2. Recommended approach
- High-level approach (how we'll implement)
- Key design choices and rationale
- Assumptions (explicit)

## 3. Alternatives considered (1–2)
1. Alternative — pros/cons — why not chosen
2. Alternative — pros/cons — why not chosen

## 4. File-by-file change list
> Each entry must include: **path → change → why**

- \`path/to/file.ext\`
  - Change:
  - Why:
  - Notes (optional):
- ...

## 5. Data / API changes
- **Data model / schema:** (what changes)
- **Migrations:** (steps + sequencing)
- **API / contracts:** (endpoints/events/types, backwards compatibility)
- **Compatibility notes:** (clients, versions, fallbacks)

## 6. UX / behavior notes (if applicable)
- User-facing flows
- Edge cases + empty states
- Error handling and messages
- Accessibility / performance notes (if relevant)

## 7. Risks & mitigations
- Risk:
  - Impact:
  - Mitigation:

## 8. Test plan
- **Unit tests:** what + where
- **Integration tests:** what + where
- **E2E tests:** what + where
- **Manual QA checklist:** steps to verify
- **Test commands:** (exact commands)

## 9. Rollout plan
- Feature flags (if any)
- Migration sequencing (if any)
- Backward compatibility strategy
- Monitoring/alerting signals to watch
- Rollback plan

## 10. Implementation checklist
- [ ] Clarify open questions / confirm assumptions
- [ ] Update types/schemas/contracts
- [ ] Implement core logic
- [ ] Wire up UI/handlers (if applicable)
- [ ] Add/adjust tests
- [ ] Update docs/README (if needed)
- [ ] Verify acceptance criteria
- [ ] Roll out safely
`;
}

function getPrReviewsPlaceholder(): string {
    return `# Pre-push Review Template

> This is a template showing the expected structure for pre-push reviews.
> Actual files will be named: \`YYYY-MM-DD_HHMMSS_<id>_<descriptor>.md\`
> Generated by: \`.ai/prompts/pre_push_review.md\`

## 1. Summary + risk
- What changed, why, and risk level (low/med/high)

## 2. Findings (bullets, prioritized)
- Finding 1
- Finding 2
- ...

## 3. Suggested diffs/changes (only if necessary)
- Change 1
- Change 2
- ...

## 4. Pre-push checklist (tickable)
- [ ] Item 1
- [ ] Item 2
- ...

## 5. Follow-ups (nice-to-haves)
- Follow-up 1
- Follow-up 2
- ...
`;
}

export type GitignoreMode = "prompt" | "add" | "skip";

function toGitignorePath(workspaceFlag: string | undefined, workspaceDir: string): string {
    // Prefer the flag value if it is relative; otherwise, use a relative path from repo root.
    const candidate = workspaceFlag ?? ".ai";
    const rel = path.isAbsolute(candidate) ? path.relative(process.cwd(), workspaceDir) : candidate;
    const normalized = rel.split(path.sep).join("/");
    return normalized.endsWith("/") ? normalized : `${normalized}/`;
}

async function hasGitignoreEntry(opts: { repoRoot: string; entry: string }): Promise<boolean> {
    const gitignorePath = path.join(opts.repoRoot, ".gitignore");
    let current = "";
    try {
        current = await fs.readFile(gitignorePath, "utf8");
    } catch {
        return false;
    }

    const normalizedEntry = opts.entry.endsWith("/") ? opts.entry : `${opts.entry}/`;
    const lines = current.split(/\r?\n/);
    return lines.some((l) => l.trim() === normalizedEntry);
}

async function ensureGitignoreEntry(opts: { repoRoot: string; entry: string }): Promise<{ changed: boolean }> {
    const gitignorePath = path.join(opts.repoRoot, ".gitignore");
    let current = "";
    try {
        current = await fs.readFile(gitignorePath, "utf8");
    } catch {
        current = "";
    }

    const normalizedEntry = opts.entry.endsWith("/") ? opts.entry : `${opts.entry}/`;
    const lines = current.split(/\r?\n/);

    // Check if entry already exists
    const entryIndex = lines.findIndex((l) => l.trim() === normalizedEntry);
    if (entryIndex !== -1) {
        // Entry exists - check if it's already in the "# AI" section
        let aiSectionStart = -1;
        let aiSectionEnd = -1;
        for (let i = 0; i < lines.length; i++) {
            if (lines[i].trim() === "# AI") {
                aiSectionStart = i;
                // Find the end of the section (next section header or end of file)
                for (let j = i + 1; j < lines.length; j++) {
                    if (lines[j].trim().startsWith("#") && lines[j].trim() !== "# AI") {
                        aiSectionEnd = j;
                        break;
                    }
                }
                if (aiSectionEnd === -1) {
                    aiSectionEnd = lines.length;
                }
                break;
            }
        }

        // If entry is already in the "# AI" section, no change needed
        if (aiSectionStart !== -1 && entryIndex >= aiSectionStart && entryIndex < aiSectionEnd) {
            return { changed: false };
        }

        // Entry exists but not in "# AI" section - we'll move it
        // Remove the entry from its current location
        lines.splice(entryIndex, 1);
    }

    // Find or create "# AI" section
    let aiSectionStart = -1;
    let aiSectionEnd = -1;
    for (let i = 0; i < lines.length; i++) {
        if (lines[i].trim() === "# AI") {
            aiSectionStart = i;
            // Find the end of the section (next section header or end of file)
            for (let j = i + 1; j < lines.length; j++) {
                if (lines[j].trim().startsWith("#") && lines[j].trim() !== "# AI") {
                    aiSectionEnd = j;
                    break;
                }
            }
            if (aiSectionEnd === -1) {
                aiSectionEnd = lines.length;
            }
            break;
        }
    }

    if (aiSectionStart === -1) {
        // "# AI" section doesn't exist - create it at the end
        // Ensure we have a blank line before the section if file is not empty
        const needsBlankLine = lines.length > 0 && lines[lines.length - 1].trim() !== "";
        const newLines = needsBlankLine ? ["", "# AI", normalizedEntry] : ["# AI", normalizedEntry];
        const next = [...lines, ...newLines].join("\n") + "\n";
        await fs.writeFile(gitignorePath, next, "utf8");
        return { changed: true };
    }

    // "# AI" section exists - add entry to it
    // Check if entry is already in the section (shouldn't happen due to earlier check, but be safe)
    const inSection = lines.slice(aiSectionStart, aiSectionEnd).some((l) => l.trim() === normalizedEntry);
    if (inSection) {
        return { changed: false };
    }

    // Find the last non-empty line in the "# AI" section to append after it
    let insertIndex = aiSectionEnd;
    for (let i = aiSectionEnd - 1; i > aiSectionStart; i--) {
        if (lines[i].trim() !== "") {
            insertIndex = i + 1;
            break;
        }
    }
    // If section only has the header, insert after header
    if (insertIndex === aiSectionEnd && aiSectionStart + 1 >= aiSectionEnd) {
        insertIndex = aiSectionStart + 1;
    }

    lines.splice(insertIndex, 0, normalizedEntry);
    const next = lines.join("\n") + "\n";
    await fs.writeFile(gitignorePath, next, "utf8");
    return { changed: true };
}

async function promptYesNo(question: string): Promise<boolean> {
    const rl = readline.createInterface({ input, output });
    try {
        const ans = (await rl.question(question)).trim().toLowerCase();
        return ans === "y" || ans === "yes";
    } finally {
        rl.close();
    }
}

/**
 *
 * @param opts
 * @param opts.workspace
 * @param opts.force
 * @param opts.gitignoreMode
 * @param opts.withAgents
 * @param opts.withHooks
 */
export async function runSetup(opts: {
    workspace?: string;
    force: boolean;
    gitignoreMode: GitignoreMode;
    withAgents?: boolean;
    withHooks?: boolean;
}): Promise<void> {
    const { workspaceDir, promptsDir } = resolveWorkspacePaths(opts.workspace);
    await mkdirp(promptsDir);

    // README
    const readmePath = path.join(workspaceDir, "README.md");
    const readme = [
        "# `.ai/` prompt library",
        "",
        "This folder contains repo-local prompts you can paste into Cursor chat.",
        "",
        "## CLI usage",
        "- `aiw setup`: create/refresh the prompt library files (idempotent by default)",
        "- `aiw list`: list available prompts",
        "- `aiw show <name>`: print a prompt to stdout",
        "- `aiw copy <name>`: copy a prompt to clipboard (fallback: print)",
        "- `aiw open <name>`: open the prompt file (or print path)",
        "- `aiw new <name>`: scaffold a new prompt",
        "",
        "## Workspace flag",
        "All commands support `--workspace <path>` (default `.ai`).",
        "",
        "## Context files",
        "",
        "The `context/` directory contains versioned artifacts generated by prompts:",
        "",
        "- `repo_context/` - Repository discovery notes (single file, updated in place)",
        "- `pr_reviews/` - Versioned pre-push review notes",
        "- `feature_plans/` - Versioned feature planning documents",
        "- `debug_notes/` - Versioned debugging session notes",
        "",
        "### Versioned files",
        "",
        "Files in `pr_reviews/`, `feature_plans/`, and `debug_notes/` use this naming format:",
        "",
        "`YYYY-MM-DD_HHMMSS_<id>_<descriptor>.md`",
        "",
        "- `YYYY-MM-DD_HHMMSS` - Timestamp when file was created",
        "- `<id>` - Unique 6-8 character identifier",
        "- `<descriptor>` - Descriptive name (includes branch name for features/bugs)",
        "",
        "Examples:",
        "- `2024-01-15_143022_a3f9b2_feature-user-auth_oauth-integration.md`",
        "- `2024-01-15_143022_b7c4d1_bugfix-login-error_null-pointer.md`",
        "",
        "### Finding files",
        "",
        "- List all files: `ls .ai/context/pr_reviews/` (or `feature_plans/`, `debug_notes/`)",
        "- Find by date: `ls .ai/context/feature_plans/ | grep 2024-01-15`",
        "- Find by branch: `ls .ai/context/feature_plans/ | grep feature-user-auth`",
        "",
    ].join("\n");
    await safeWriteFile(readmePath, readme, { force: opts.force });

    // Default prompts
    for (const p of DEFAULT_PROMPTS) {
        const filePath = path.join(promptsDir, p.filename);
        await safeWriteFile(filePath, p.contents, { force: opts.force });
    }

    // Create context directory for artifacts
    const contextDir = path.join(workspaceDir, "context");
    await mkdirp(contextDir);

    // Create subdirectories
    const subdirs = ["repo_context", "pr_reviews", "feature_plans", "debug_notes"];
    for (const subdir of subdirs) {
        const subdirPath = path.join(contextDir, subdir);
        await mkdirp(subdirPath);

        // Create README.md in each subdirectory
        const readmeContent = getSubdirectoryReadme(subdir);
        await safeWriteFile(path.join(subdirPath, "README.md"), readmeContent, { force: false });
    }

    // Create REPO_CONTEXT.md (single file, not versioned) in repo_context subdirectory
    await safeWriteFile(
        path.join(contextDir, "repo_context", "REPO_CONTEXT.md"),
        "# REPO_CONTEXT\n\n(Generated/updated by using `.ai/prompts/repo_discover.md` and `.ai/prompts/repo_refresh.md`)\n",
        { force: false },
    );

    // Create placeholder files for versioned context directories
    await safeWriteFile(path.join(contextDir, "debug_notes", "_example.md"), getDebugNotesPlaceholder(), { force: false });
    await safeWriteFile(path.join(contextDir, "feature_plans", "_example.md"), getFeaturePlansPlaceholder(), { force: false });
    await safeWriteFile(path.join(contextDir, "pr_reviews", "_example.md"), getPrReviewsPlaceholder(), { force: false });

    // .gitignore handling
    const mode = opts.gitignoreMode === "prompt" && !process.stdout.isTTY ? "skip" : opts.gitignoreMode;
    const gitignoreEntry = toGitignorePath(opts.workspace, workspaceDir);

    if (mode === "add") {
        await ensureGitignoreEntry({
            repoRoot: process.cwd(),
            entry: gitignoreEntry,
        });
    } else if (mode === "prompt") {
        // Check if entry already exists - if so, skip the prompt
        const alreadyExists = await hasGitignoreEntry({
            repoRoot: process.cwd(),
            entry: gitignoreEntry,
        });
        if (!alreadyExists) {
            const yes = await promptYesNo(`Add ${gitignoreEntry} to .gitignore? (y/N) `);
            if (yes) {
                await ensureGitignoreEntry({
                    repoRoot: process.cwd(),
                    entry: gitignoreEntry,
                });
            }
        }
    }

    // Always create docs/PROJECT_CONTEXT.md if it doesn't exist
    const repoRoot = process.cwd();
    const workspaceDirRelative = opts.workspace ?? ".ai";
    const repoContextPath = path.join(workspaceDirRelative, "context", "repo_context", "REPO_CONTEXT.md");
    const projectContextPath = "docs/PROJECT_CONTEXT.md";
    const projectContextFullPath = path.join(repoRoot, projectContextPath);

    // Create PROJECT_CONTEXT.md (only if it doesn't exist, unless --force)
    const projectContextContent = await getProjectContextContent(repoContextPath, repoRoot);
    await safeWriteFile(projectContextFullPath, projectContextContent, { force: opts.force });

    // Scaffold agent rules if requested
    if (opts.withAgents) {
        // Scaffold agent rule files
        const ruleFiles = getAgentRuleFiles(projectContextPath, repoContextPath);
        for (const ruleFile of ruleFiles) {
            const ruleFilePath = path.join(repoRoot, ruleFile.path);
            await mkdirp(path.dirname(ruleFilePath));
            await safeWriteFile(ruleFilePath, ruleFile.content, { force: opts.force });
        }
    }

    // Install pre-push hook if requested
    if (opts.withHooks) {
        const hookResult = await installPrePushHook();
        if (!hookResult.installed && hookResult.message) {
            // Log warning but don't fail setup
            process.stderr.write(`Warning: ${hookResult.message}\n`);
        }
    }
}

/**
 *
 */
export function setupCommand(): Command {
    const cmd = new Command("setup")
        .description("Create the .ai prompt library structure and default prompts")
        .option("--workspace <path>", "Workspace folder (default: .ai)")
        .option("--force", "Overwrite managed files (creates backups)", false)
        .option("--gitignore <mode>", "prompt|add|skip (default: prompt in TTY, else skip)", "prompt")
        .option("--with-agents", "Scaffold agent rule files (AGENTS.md, CLAUDE.md, .cursor/rules/)", false)
        .option("--with-hooks", "Install git pre-push hook for context enforcement", false);

    cmd.action(async (options: { workspace?: string; force?: boolean; gitignore?: string; withAgents?: boolean; withHooks?: boolean }) => {
        const mode = String(options.gitignore ?? "prompt") as GitignoreMode;
        if (!["prompt", "add", "skip"].includes(mode)) {
            throw new Error("Invalid --gitignore value. Use: prompt|add|skip");
        }

        await runSetup({
            workspace: options.workspace,
            force: Boolean(options.force),
            gitignoreMode: mode,
            withAgents: Boolean(options.withAgents),
            withHooks: Boolean(options.withHooks),
        });

        process.stdout.write("Setup complete.\n");
    });

    return cmd;
}
