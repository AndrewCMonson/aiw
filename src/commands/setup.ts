/**
 * @copyright Copyright Â© 2025 Andrew Monson. All rights reserved.
 * @author    Andrew Monson <andrew.monson@elevate-digital.com>
 */

import { Command } from "commander";
import { readFileSync } from "node:fs";
import fs from "node:fs/promises";
import path from "node:path";
import { stdin as input, stdout as output } from "node:process";
import readline from "node:readline/promises";
import { fileURLToPath } from "node:url";

import { mkdirp, safeWriteFile } from "../lib/fs.js";
import { installPrePushHook } from "../lib/hooks.js";
import { resolveWorkspacePaths } from "../lib/paths.js";
import { getAgentRuleFiles } from "../templates/agentRules.js";
import { DEFAULT_PROMPTS } from "../templates/defaultPrompts.js";
import { getProjectContextContent } from "../templates/projectContext.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const templatesDir = path.join(__dirname, "..", "templates", "setup");

// Load markdown templates at module initialization
const WORKSPACE_README = readFileSync(path.join(templatesDir, "workspace-readme.md"), "utf8");
const REPO_CONTEXT_README = readFileSync(path.join(templatesDir, "repo-context-readme.md"), "utf8");
const VERSIONED_README = readFileSync(path.join(templatesDir, "versioned-readme.md"), "utf8");
const DEBUG_NOTES_PLACEHOLDER = readFileSync(path.join(templatesDir, "debug-notes-placeholder.md"), "utf8");
const FEATURE_PLANS_PLACEHOLDER = readFileSync(path.join(templatesDir, "feature-plans-placeholder.md"), "utf8");
const PR_REVIEWS_PLACEHOLDER = readFileSync(path.join(templatesDir, "pr-reviews-placeholder.md"), "utf8");
const REPO_CONTEXT_INITIAL = readFileSync(path.join(templatesDir, "repo-context-initial.md"), "utf8");

/**
 * Simple template replacement function.
 * @param template
 * @param vars
 */
function replaceTemplateVars(template: string, vars: Record<string, string>): string {
    return template.replace(/\$\{(\w+)\}/g, (_, key) => vars[key] ?? `\${${key}}`);
}

function getSubdirectoryReadme(subdir: string): string {
    const descriptions: Record<string, { title: string; description: string }> = {
        repo_context: {
            title: "Repository Context",
            description:
                "Repository discovery notes (single file, updated in place) generated by `.ai/prompts/repo_discover.md` and `.ai/prompts/repo_refresh.md`",
        },
        pr_reviews: {
            title: "Pre-push Reviews",
            description: "Versioned pre-push review notes generated by `.ai/prompts/pre_push_review.md`",
        },
        feature_plans: {
            title: "Feature Plans",
            description: "Versioned feature planning documents generated by `.ai/prompts/feature_plan.md`",
        },
        debug_notes: {
            title: "Debug Notes",
            description: "Versioned debugging session notes generated by `.ai/prompts/debug_senior.md`",
        },
    };

    const info = descriptions[subdir] || { title: subdir, description: "Versioned context files" };

    if (subdir === "repo_context") {
        return replaceTemplateVars(REPO_CONTEXT_README, {
            title: info.title,
            description: info.description,
        });
    }

    return replaceTemplateVars(VERSIONED_README, {
        title: info.title,
        description: info.description,
        subdir,
    });
}

function getDebugNotesPlaceholder(): string {
    return DEBUG_NOTES_PLACEHOLDER;
}

function getFeaturePlansPlaceholder(): string {
    return FEATURE_PLANS_PLACEHOLDER;
}

function getPrReviewsPlaceholder(): string {
    return PR_REVIEWS_PLACEHOLDER;
}

export type GitignoreMode = "prompt" | "add" | "skip";

function toGitignorePath(workspaceFlag: string | undefined, workspaceDir: string): string {
    // Prefer the flag value if it is relative; otherwise, use a relative path from repo root.
    const candidate = workspaceFlag ?? ".ai";
    const rel = path.isAbsolute(candidate) ? path.relative(process.cwd(), workspaceDir) : candidate;
    const normalized = rel.split(path.sep).join("/");
    return normalized.endsWith("/") ? normalized : `${normalized}/`;
}

async function hasGitignoreEntry(opts: { repoRoot: string; entry: string }): Promise<boolean> {
    const gitignorePath = path.join(opts.repoRoot, ".gitignore");
    let current = "";
    try {
        current = await fs.readFile(gitignorePath, "utf8");
    } catch {
        return false;
    }

    const normalizedEntry = opts.entry.endsWith("/") ? opts.entry : `${opts.entry}/`;
    const lines = current.split(/\r?\n/);
    return lines.some((l) => l.trim() === normalizedEntry);
}

async function ensureGitignoreEntry(opts: { repoRoot: string; entry: string }): Promise<{ changed: boolean }> {
    const gitignorePath = path.join(opts.repoRoot, ".gitignore");
    let current = "";
    try {
        current = await fs.readFile(gitignorePath, "utf8");
    } catch {
        current = "";
    }

    const normalizedEntry = opts.entry.endsWith("/") ? opts.entry : `${opts.entry}/`;
    const lines = current.split(/\r?\n/);

    // Check if entry already exists
    const entryIndex = lines.findIndex((l) => l.trim() === normalizedEntry);
    if (entryIndex !== -1) {
        // Entry exists - check if it's already in the "# AI" section
        let aiSectionStart = -1;
        let aiSectionEnd = -1;
        for (let i = 0; i < lines.length; i++) {
            if (lines[i].trim() === "# AI") {
                aiSectionStart = i;
                // Find the end of the section (next section header or end of file)
                for (let j = i + 1; j < lines.length; j++) {
                    if (lines[j].trim().startsWith("#") && lines[j].trim() !== "# AI") {
                        aiSectionEnd = j;
                        break;
                    }
                }
                if (aiSectionEnd === -1) {
                    aiSectionEnd = lines.length;
                }
                break;
            }
        }

        // If entry is already in the "# AI" section, no change needed
        if (aiSectionStart !== -1 && entryIndex >= aiSectionStart && entryIndex < aiSectionEnd) {
            return { changed: false };
        }

        // Entry exists but not in "# AI" section - we'll move it
        // Remove the entry from its current location
        lines.splice(entryIndex, 1);
    }

    // Find or create "# AI" section
    let aiSectionStart = -1;
    let aiSectionEnd = -1;
    for (let i = 0; i < lines.length; i++) {
        if (lines[i].trim() === "# AI") {
            aiSectionStart = i;
            // Find the end of the section (next section header or end of file)
            for (let j = i + 1; j < lines.length; j++) {
                if (lines[j].trim().startsWith("#") && lines[j].trim() !== "# AI") {
                    aiSectionEnd = j;
                    break;
                }
            }
            if (aiSectionEnd === -1) {
                aiSectionEnd = lines.length;
            }
            break;
        }
    }

    if (aiSectionStart === -1) {
        // "# AI" section doesn't exist - create it at the end
        // Ensure we have a blank line before the section if file is not empty
        const needsBlankLine = lines.length > 0 && lines[lines.length - 1].trim() !== "";
        const newLines = needsBlankLine ? ["", "# AI", normalizedEntry] : ["# AI", normalizedEntry];
        const next = [...lines, ...newLines].join("\n") + "\n";
        await fs.writeFile(gitignorePath, next, "utf8");
        return { changed: true };
    }

    // "# AI" section exists - add entry to it
    // Check if entry is already in the section (shouldn't happen due to earlier check, but be safe)
    const inSection = lines.slice(aiSectionStart, aiSectionEnd).some((l) => l.trim() === normalizedEntry);
    if (inSection) {
        return { changed: false };
    }

    // Find the last non-empty line in the "# AI" section to append after it
    let insertIndex = aiSectionEnd;
    for (let i = aiSectionEnd - 1; i > aiSectionStart; i--) {
        if (lines[i].trim() !== "") {
            insertIndex = i + 1;
            break;
        }
    }
    // If section only has the header, insert after header
    if (insertIndex === aiSectionEnd && aiSectionStart + 1 >= aiSectionEnd) {
        insertIndex = aiSectionStart + 1;
    }

    lines.splice(insertIndex, 0, normalizedEntry);
    const next = lines.join("\n") + "\n";
    await fs.writeFile(gitignorePath, next, "utf8");
    return { changed: true };
}

async function ensureReceiptsGitignoreException(opts: { repoRoot: string }): Promise<{ changed: boolean }> {
    const gitignorePath = path.join(opts.repoRoot, ".gitignore");
    let current = "";
    try {
        current = await fs.readFile(gitignorePath, "utf8");
    } catch {
        current = "";
    }

    const lines = current.split(/\r?\n/);
    const sectionHeader = "# AIW receipts (tracked for CI verification)";
    const exceptionEntry = "!.aiw/receipts/";

    // Check if exception already exists
    const hasException = lines.some((l) => l.trim() === exceptionEntry);
    if (hasException) {
        return { changed: false };
    }

    // Find or create "# AIW receipts" section
    let sectionStart = -1;
    let sectionEnd = -1;
    for (let i = 0; i < lines.length; i++) {
        if (lines[i].trim() === sectionHeader) {
            sectionStart = i;
            // Find the end of the section (next section header or end of file)
            for (let j = i + 1; j < lines.length; j++) {
                if (lines[j].trim().startsWith("#") && lines[j].trim() !== sectionHeader) {
                    sectionEnd = j;
                    break;
                }
            }
            if (sectionEnd === -1) {
                sectionEnd = lines.length;
            }
            break;
        }
    }

    if (sectionStart === -1) {
        // Section doesn't exist - create it at the end
        // Ensure we have a blank line before the section if file is not empty
        const needsBlankLine = lines.length > 0 && lines[lines.length - 1].trim() !== "";
        const newLines = needsBlankLine ? ["", sectionHeader, exceptionEntry] : [sectionHeader, exceptionEntry];
        const next = [...lines, ...newLines].join("\n") + "\n";
        await fs.writeFile(gitignorePath, next, "utf8");
        return { changed: true };
    }

    // Section exists - add exception entry to it
    // Check if entry is already in the section (shouldn't happen due to earlier check, but be safe)
    const inSection = lines.slice(sectionStart, sectionEnd).some((l) => l.trim() === exceptionEntry);
    if (inSection) {
        return { changed: false };
    }

    // Find the last non-empty line in the section to append after it
    let insertIndex = sectionEnd;
    for (let i = sectionEnd - 1; i > sectionStart; i--) {
        if (lines[i].trim() !== "") {
            insertIndex = i + 1;
            break;
        }
    }
    // If section only has the header, insert after header
    if (insertIndex === sectionEnd && sectionStart + 1 >= sectionEnd) {
        insertIndex = sectionStart + 1;
    }

    lines.splice(insertIndex, 0, exceptionEntry);
    const next = lines.join("\n") + "\n";
    await fs.writeFile(gitignorePath, next, "utf8");
    return { changed: true };
}

async function promptYesNo(question: string): Promise<boolean> {
    const rl = readline.createInterface({ input, output });
    try {
        const ans = (await rl.question(question)).trim().toLowerCase();
        return ans === "y" || ans === "yes";
    } finally {
        rl.close();
    }
}

/**
 *
 * @param opts
 * @param opts.workspace
 * @param opts.force
 * @param opts.gitignoreMode
 * @param opts.withAgents
 * @param opts.withHooks
 */
export async function runSetup(opts: {
    workspace?: string;
    force: boolean;
    gitignoreMode: GitignoreMode;
    withAgents?: boolean;
    withHooks?: boolean;
}): Promise<void> {
    const { workspaceDir, promptsDir } = resolveWorkspacePaths(opts.workspace);
    await mkdirp(promptsDir);

    // README
    const readmePath = path.join(workspaceDir, "README.md");
    await safeWriteFile(readmePath, WORKSPACE_README, { force: opts.force });

    // Default prompts (each in its own subdirectory)
    for (const p of DEFAULT_PROMPTS) {
        const promptDir = path.join(promptsDir, p.slug);
        await mkdirp(promptDir);
        const filePath = path.join(promptDir, p.filename);
        await safeWriteFile(filePath, p.contents, { force: opts.force });
    }

    // Create context directory for artifacts
    const contextDir = path.join(workspaceDir, "context");
    await mkdirp(contextDir);

    // Create subdirectories
    const subdirs = ["repo_context", "pr_reviews", "feature_plans", "debug_notes"];
    for (const subdir of subdirs) {
        const subdirPath = path.join(contextDir, subdir);
        await mkdirp(subdirPath);

        // Create README.md in each subdirectory
        const readmeContent = getSubdirectoryReadme(subdir);
        await safeWriteFile(path.join(subdirPath, "README.md"), readmeContent, { force: false });
    }

    // Create REPO_CONTEXT.md (single file, not versioned) in repo_context subdirectory
    await safeWriteFile(path.join(contextDir, "repo_context", "REPO_CONTEXT.md"), REPO_CONTEXT_INITIAL, { force: false });

    // Create placeholder files for versioned context directories
    await safeWriteFile(path.join(contextDir, "debug_notes", "_example.md"), getDebugNotesPlaceholder(), { force: false });
    await safeWriteFile(path.join(contextDir, "feature_plans", "_example.md"), getFeaturePlansPlaceholder(), { force: false });
    await safeWriteFile(path.join(contextDir, "pr_reviews", "_example.md"), getPrReviewsPlaceholder(), { force: false });

    // .gitignore handling
    const mode = opts.gitignoreMode === "prompt" && !process.stdout.isTTY ? "skip" : opts.gitignoreMode;
    const gitignoreEntry = toGitignorePath(opts.workspace, workspaceDir);

    if (mode === "add") {
        await ensureGitignoreEntry({
            repoRoot: process.cwd(),
            entry: gitignoreEntry,
        });
    } else if (mode === "prompt") {
        // Check if entry already exists - if so, skip the prompt
        const alreadyExists = await hasGitignoreEntry({
            repoRoot: process.cwd(),
            entry: gitignoreEntry,
        });
        if (!alreadyExists) {
            const yes = await promptYesNo(`Add ${gitignoreEntry} to .gitignore? (y/N) `);
            if (yes) {
                await ensureGitignoreEntry({
                    repoRoot: process.cwd(),
                    entry: gitignoreEntry,
                });
            }
        }
    }

    // Always ensure .aiw/receipts/ exception is in .gitignore (required for receipt mechanism)
    await ensureReceiptsGitignoreException({
        repoRoot: process.cwd(),
    });

    // Always create docs/PROJECT_CONTEXT.md if it doesn't exist
    const repoRoot = process.cwd();
    const workspaceDirRelative = opts.workspace ?? ".ai";
    const repoContextPath = path.join(workspaceDirRelative, "context", "repo_context", "REPO_CONTEXT.md");
    const projectContextPath = "docs/PROJECT_CONTEXT.md";
    const projectContextFullPath = path.join(repoRoot, projectContextPath);

    // Create PROJECT_CONTEXT.md (only if it doesn't exist)
    const projectContextContent = await getProjectContextContent(repoContextPath, repoRoot);
    await safeWriteFile(projectContextFullPath, projectContextContent, { force: false });

    // Scaffold agent rules if requested
    if (opts.withAgents) {
        // Scaffold agent rule files
        const ruleFiles = getAgentRuleFiles(projectContextPath, repoContextPath);
        for (const ruleFile of ruleFiles) {
            const ruleFilePath = path.join(repoRoot, ruleFile.path);
            await mkdirp(path.dirname(ruleFilePath));
            await safeWriteFile(ruleFilePath, ruleFile.content, { force: opts.force });
        }
    }

    // Install pre-push hook if requested
    if (opts.withHooks) {
        const hookResult = await installPrePushHook();
        if (!hookResult.installed && hookResult.message) {
            // Log warning but don't fail setup
            process.stderr.write(`Warning: ${hookResult.message}\n`);
        }
    }
}

/**
 *
 */
export function setupCommand(): Command {
    const cmd = new Command("setup")
        .description("Create the .ai prompt library structure and default prompts")
        .option("--workspace <path>", "Workspace folder (default: .ai)")
        .option("--force", "Overwrite managed files (creates backups)", false)
        .option("--gitignore <mode>", "prompt|add|skip (default: prompt in TTY, else skip)", "prompt")
        .option("--with-agents", "Scaffold agent rule files (AGENTS.md, CLAUDE.md, .cursor/rules/)", false)
        .option("--with-hooks", "Install git pre-push hook for context enforcement", false);

    cmd.action(async (options: { workspace?: string; force?: boolean; gitignore?: string; withAgents?: boolean; withHooks?: boolean }) => {
        const mode = String(options.gitignore ?? "prompt") as GitignoreMode;
        if (!["prompt", "add", "skip"].includes(mode)) {
            throw new Error("Invalid --gitignore value. Use: prompt|add|skip");
        }

        await runSetup({
            workspace: options.workspace,
            force: Boolean(options.force),
            gitignoreMode: mode,
            withAgents: Boolean(options.withAgents),
            withHooks: Boolean(options.withHooks),
        });

        process.stdout.write("Setup complete.\n");
    });

    return cmd;
}
