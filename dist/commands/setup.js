import fs from "node:fs/promises";
import path from "node:path";
import readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";
import { Command } from "commander";
import { mkdirp, safeWriteFile } from "../lib/fs.js";
import { resolveWorkspacePaths } from "../lib/paths.js";
import { DEFAULT_PROMPTS } from "../templates/defaultPrompts.js";
function getSubdirectoryReadme(subdir) {
    const descriptions = {
        pr_reviews: {
            title: "Pre-push Reviews",
            description: "Versioned pre-push review notes generated by `.ai/prompts/pre_push_review.md`"
        },
        feature_plans: {
            title: "Feature Plans",
            description: "Versioned feature planning documents generated by `.ai/prompts/feature_plan.md`"
        },
        debug_notes: {
            title: "Debug Notes",
            description: "Versioned debugging session notes generated by `.ai/prompts/debug_senior.md`"
        }
    };
    const info = descriptions[subdir] || { title: subdir, description: "Versioned context files" };
    return `# ${info.title}

${info.description}

## Filename Format

Files in this directory use the following naming format:

\`YYYY-MM-DD_HHMMSS_<id>_<descriptor>.md\`

- \`YYYY-MM-DD_HHMMSS\` - Timestamp when the file was created (24-hour format)
- \`<id>\` - Unique 6-8 character identifier
- \`<descriptor>\` - Descriptive name (includes branch name for features/bugs)

## Examples

- \`2024-01-15_143022_a3f9b2_feature-user-auth_oauth-integration.md\`
- \`2024-01-15_143022_b7c4d1_bugfix-login-error_null-pointer.md\`

## Finding Files

- List all files: \`ls .ai/context/${subdir}/\`
- Find by date: \`ls .ai/context/${subdir}/ | grep 2024-01-15\`
- Find by branch: \`ls .ai/context/${subdir}/ | grep feature-user-auth\`
`;
}
function toGitignorePath(workspaceFlag, workspaceDir) {
    // Prefer the flag value if it is relative; otherwise, use a relative path from repo root.
    const candidate = workspaceFlag ?? ".ai";
    const rel = path.isAbsolute(candidate) ? path.relative(process.cwd(), workspaceDir) : candidate;
    const normalized = rel.split(path.sep).join("/");
    return normalized.endsWith("/") ? normalized : `${normalized}/`;
}
async function ensureGitignoreEntry(opts) {
    const gitignorePath = path.join(opts.repoRoot, ".gitignore");
    let current = "";
    try {
        current = await fs.readFile(gitignorePath, "utf8");
    }
    catch {
        current = "";
    }
    const normalizedEntry = opts.entry.endsWith("/") ? opts.entry : `${opts.entry}/`;
    const lines = current.split(/\r?\n/);
    const has = lines.some((l) => l.trim() === normalizedEntry);
    if (has)
        return { changed: false };
    const next = (current.trimEnd() + "\n" + normalizedEntry + "\n").replace(/^\n+/, "");
    await fs.writeFile(gitignorePath, next, "utf8");
    return { changed: true };
}
async function promptYesNo(question) {
    const rl = readline.createInterface({ input, output });
    try {
        const ans = (await rl.question(question)).trim().toLowerCase();
        return ans === "y" || ans === "yes";
    }
    finally {
        rl.close();
    }
}
export async function runSetup(opts) {
    const { workspaceDir, promptsDir } = resolveWorkspacePaths(opts.workspace);
    await mkdirp(promptsDir);
    // README
    const readmePath = path.join(workspaceDir, "README.md");
    const readme = [
        "# `.ai/` prompt library",
        "",
        "This folder contains repo-local prompts you can paste into Cursor chat.",
        "",
        "## CLI usage",
        "- `aiw setup`: create/refresh the prompt library files (idempotent by default)",
        "- `aiw list`: list available prompts",
        "- `aiw show <name>`: print a prompt to stdout",
        "- `aiw copy <name>`: copy a prompt to clipboard (fallback: print)",
        "- `aiw open <name>`: open the prompt file (or print path)",
        "- `aiw new <name>`: scaffold a new prompt",
        "",
        "## Workspace flag",
        "All commands support `--workspace <path>` (default `.ai`).",
        "",
        "## Context files",
        "",
        "The `context/` directory contains versioned artifacts generated by prompts:",
        "",
        "- `REPO_CONTEXT.md` - Repository discovery notes (single file, updated in place)",
        "- `pr_reviews/` - Versioned pre-push review notes",
        "- `feature_plans/` - Versioned feature planning documents",
        "- `debug_notes/` - Versioned debugging session notes",
        "",
        "### Versioned files",
        "",
        "Files in `pr_reviews/`, `feature_plans/`, and `debug_notes/` use this naming format:",
        "",
        "`YYYY-MM-DD_HHMMSS_<id>_<descriptor>.md`",
        "",
        "- `YYYY-MM-DD_HHMMSS` - Timestamp when file was created",
        "- `<id>` - Unique 6-8 character identifier",
        "- `<descriptor>` - Descriptive name (includes branch name for features/bugs)",
        "",
        "Examples:",
        "- `2024-01-15_143022_a3f9b2_feature-user-auth_oauth-integration.md`",
        "- `2024-01-15_143022_b7c4d1_bugfix-login-error_null-pointer.md`",
        "",
        "### Finding files",
        "",
        "- List all files: `ls .ai/context/pr_reviews/` (or `feature_plans/`, `debug_notes/`)",
        "- Find by date: `ls .ai/context/feature_plans/ | grep 2024-01-15`",
        "- Find by branch: `ls .ai/context/feature_plans/ | grep feature-user-auth`",
        ""
    ].join("\n");
    await safeWriteFile(readmePath, readme, { force: opts.force });
    // Default prompts
    for (const p of DEFAULT_PROMPTS) {
        const filePath = path.join(promptsDir, p.filename);
        await safeWriteFile(filePath, p.contents, { force: opts.force });
    }
    // Create context directory for artifacts
    const contextDir = path.join(workspaceDir, "context");
    await mkdirp(contextDir);
    // Create REPO_CONTEXT.md (single file, not versioned)
    await safeWriteFile(path.join(contextDir, "REPO_CONTEXT.md"), "# REPO_CONTEXT\n\n(Generated/updated by using `.ai/prompts/repo_discover.md` and `.ai/prompts/repo_refresh.md`)\n", { force: false });
    // Create versioned subdirectories
    const subdirs = ["pr_reviews", "feature_plans", "debug_notes"];
    for (const subdir of subdirs) {
        const subdirPath = path.join(contextDir, subdir);
        await mkdirp(subdirPath);
        // Create README.md in each subdirectory
        const readmeContent = getSubdirectoryReadme(subdir);
        await safeWriteFile(path.join(subdirPath, "README.md"), readmeContent, { force: false });
    }
    // .gitignore handling
    const mode = opts.gitignoreMode === "prompt" && !process.stdout.isTTY ? "skip" : opts.gitignoreMode;
    if (mode === "add") {
        await ensureGitignoreEntry({
            repoRoot: process.cwd(),
            entry: toGitignorePath(opts.workspace, workspaceDir)
        });
    }
    else if (mode === "prompt") {
        const yes = await promptYesNo(`Add ${toGitignorePath(opts.workspace, workspaceDir)} to .gitignore? (y/N) `);
        if (yes) {
            await ensureGitignoreEntry({
                repoRoot: process.cwd(),
                entry: toGitignorePath(opts.workspace, workspaceDir)
            });
        }
    }
}
export function setupCommand() {
    const cmd = new Command("setup")
        .description("Create the .ai prompt library structure and default prompts")
        .option("--workspace <path>", "Workspace folder (default: .ai)")
        .option("--force", "Overwrite managed files (creates backups)", false)
        .option("--gitignore <mode>", "prompt|add|skip (default: prompt in TTY, else skip)", "prompt");
    cmd.action(async (options) => {
        const mode = String(options.gitignore ?? "prompt");
        if (!["prompt", "add", "skip"].includes(mode)) {
            throw new Error("Invalid --gitignore value. Use: prompt|add|skip");
        }
        await runSetup({
            workspace: options.workspace,
            force: Boolean(options.force),
            gitignoreMode: mode
        });
        process.stdout.write("Setup complete.\n");
    });
    return cmd;
}
